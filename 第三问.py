# -*- coding: utf-8 -*-
"""
__project_ = 'project'
__file_name__ = '第三问.py'
__author__ = '十五'
__email__ = '564298339@qq.com'
__time__ = '2023/5/15 2:12'
"""
from 第一问 import *

# 我在这里要给他加上5%的伸展

def 装载函数2(待装载物品序列, 待选容器表,权重_=None):
    """
    容器的数据格式: 容器元素=[物品编号,物品三维,插入坐标],容器=[本身属性[容器信息],容器元素表[容器元素],装载角表[装载角],容积],
    装载角=[坐标(x,y,z),尺寸(l,h,w),类型(x=0,y=1,z=2)]
    物品信息=[订单号,长,宽,高], 待装载物品序列 = List[物品信息]
    容器信息=[名称(数字),类型(数字),长,宽,高], 容器种类表 = List[容器信息]
    已选容器列表=[容器]
    评分信息=[旋转,坐标,已选容器编号,新容器编号,得分]
    解释:
    评分信息是指一个物品将被如何放置到容器中,
    旋转: 取值0,1,2,3,4,5分别表示长,宽,高三个数据的全排列取前两个作为物品的底面.
    已选容器编号:  如果已选容器编号=-1则考虑创建新容器
    新容器编号: 是指容器的名称编号, 通常为-1,只有需要新建容器时,才会等于指定的名称编号

    """
    权重_ = 权重() if 权重_ is None else 权重_

    已装载容器序列:"" = [] # 已装载容器序列[容器[]]
    for 新物品编号,新物品_ in enumerate(待装载物品序列):
        # 评分环节
        新物品 = [新物品_[0],新物品_[1]*.95,新物品_[2]*.95,新物品_[3]*.95]

        评分表 = []  # 包含物品评分与操作的表

        if 已装载容器序列:
            for 容器编号, 容器 in enumerate(已装载容器序列):
                装载角表 = 容器[2]
                for 装载角 in 装载角表:# 容器2 即装载角
                    if 装载函数操作_装载角能装下(装载角, 新物品):
                        角x边, 角y边, 角z边 = 装载角[1]
                        for i in range(6):
                            x边, y边, z边 = 物品操作_旋转(新物品, i)
                            if 角x边 < x边 or 角y边 < y边 or 角z边 < z边:
                                continue
                            评分 = 装载函数操作_评分(容器,x边, y边, z边,角x边, 角y边, 角z边,权重实例=权重_)
                            评分表.append([i,装载角[0],容器编号,-1,评分])
        for _,待选容器_ in enumerate(待选容器表):
            待选容器= [待选容器_[0],待选容器_[1],待选容器_[2]*1.05,待选容器_[3]*1.05,待选容器_[4]*1.05]

            待选容器编号=待选容器[0]
            角x边, 角y边, 角z边 = 待选容器[2], 待选容器[3], 待选容器[4]
            if 待选容器[1] == 1:
                for i in range(6):
                    x边, y边, z边 = 物品操作_旋转(新物品, i)
                    if 角x边<x边 or 角y边<y边 or 角z边<z边:
                        continue

                    评分 = 装载函数操作_评分(待选容器,x边, y边, z边, 角x边, 角y边, 角z边,新旧权重=权重_.新容器,权重实例=权重_)
                    评分表.append([i, (0,0,0), -1, 待选容器编号, 评分])
            else:
                容器最长, 容器次长, 容器最短 = 袋装容器_获取最大立方体的三边(待选容器)

                for i in range(6):
                    x边, y边, z边 = 物品操作_旋转(新物品, i)
                    # 超过这些厚度和宽度就无法装载了, 所以直接跳过
                    物品导出最长边 = 袋装容器_获取最长边(待选容器, x边, y边)
                    if  not (角x边+角z边>=x边+z边 and 角y边+角z边>=y边+z边 ) or 物品导出最长边 < z边:
                        continue
                    else:
                        评分 = 装载函数操作_评分(待选容器, x边, y边, z边, x边, y边, 物品导出最长边, 新旧权重=权重_.新容器,
                                       需要边=False,需要面积=False,权重实例=权重_
                                       )
                        # 评分 = 权重_.新容器 * (max(比例得分, 体积得分))
                        评分表.append([i, (0,0,0), -1, 待选容器编号, 评分])
                pass

        if len(评分表)==0:
            for _,待选容器 in enumerate(待选容器表[0:4]):
                if 新物品[1]+新物品[3]<=待选容器[2]+待选容器[4] and 新物品[2]+新物品[3]<=待选容器[3]+待选容器[4]:
                    容器 = [待选容器.copy(), [[新物品编号, 新物品[1:4], (0,0,0)]], [],新物品[1]*新物品[2]*新物品[3]]
                    已装载容器序列.append(容器)
                    break
            continue

        最佳操作 = max(评分表, key=lambda x: x[-1])
        if 最佳操作[-1] == -1:
            raise ValueError("没有最佳分数, 请检查问题")

        旋转,坐标,容器编号,新容器编号,得分 = 最佳操作
        x边, y边, z边 = 物品操作_旋转(新物品, 旋转)
        # 植入环节
        if 容器编号!=-1: # 此时将新物品插入旧的容器中
            容器 = 已装载容器序列[容器编号]
            容器[1].append([新物品编号,(x边, y边, z边),坐标])
            if 容器[0][1]==0:
                容器[3]+= x边*y边*z边
            装载角 = [角 for 角 in 容器[2] if 角[0]==坐标][0]
            容器[2].remove(装载角)
            装载函数操作_新增装载角(容器,装载角,[x边, y边, z边])
        else:# 插入新容器
            容器 = [获取容器(待选容器表,新容器编号).copy(),[[新物品编号,(x边, y边, z边),坐标]],[],0]
            容器[3] += x边*y边*z边 if 容器[0][1]==0 else 容器[0][2]*容器[0][3]*容器[0][4]
            已装载容器序列.append(容器)
            if 容器[0][1]==1:
                装载角 = [[0,0,0],容器[0][2:5],2]
            else:
                装载角 = [[0, 0, 0],[x边, y边, 袋装容器_获取最长边(容器[0], x边, y边)], 2]
            装载函数操作_新增装载角(容器,装载角, [x边, y边, z边])
            pass
    return 已装载容器序列


"""
313, 109, 400, 1  , 202,
290, 214,  42, 131, 208,
391, 349, 149, 400, 156,
23 , 36 , 1 ,  1  , 194,
1  , 1  , 74, 177 , 34,
1 ,  358, 
"""

def 适应度函数2(个体=None, 耗材表=混合装):

    # for 容器种类表 in [只用箱装,只用袋装,混合装]:
    总消耗序列 = []
    总订单序列 = []
    总体积 = 0
    总箱子体积=0
    总箱子个数=0
    总袋子个数=0
    总袋子体积=0
    for 物品序列 in 订单字典.values():

        结果 = 装载函数2(物品序列,耗材表,权重(个体))
        总消耗序列.append(len(结果))
        总订单序列.append(结果)
        总体积 +=sum([容器[3]/1000000 for 容器 in 结果])
        总箱子个数 +=sum([1 for 容器 in 结果 if 容器[0][1]==1])
        总袋子个数 +=sum([1 for 容器 in 结果 if 容器[0][1]==0])
        总箱子体积 +=sum([容器[3]/1000000 for 容器 in 结果 if 容器[0][1]==1])
        总袋子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 0])
    # print(sum(总消耗序列),"箱子=",sum([sum([1 for 容器 in 订单 if 容器[0][1]==1]) for 订单 in 总订单序列]),
    #       "袋子=",sum([sum([1 for 容器 in 订单 if 容器[0][1]==0]) for 订单 in 总订单序列]),
    #       )

    总消耗个数 = sum(总消耗序列)

    print(个体,"总消耗个数=",sum(总消耗序列),"总体积=",总体积,
          "箱子个数=",总箱子个数,"箱子体积=",总箱子体积,
          "袋子个数=",总袋子个数,"袋子体积=",总袋子体积,
          )
    return sum(总消耗序列)
    pass

def 差分进化2(容器列表=混合装):


    # def f(x):
    #     return sum((x - 0.5) ** 2)


    bounds = [(0,5) for i in 权重().权重值表]

    for best, fit in list(de(lambda x:适应度函数2(x, 容器列表), bounds, its=30,
                             #initpop=np.array([ [0.34185236, 4.52230808, 2.28562625, 5.,         0.72258032, 5.,0.] for i in range(10)])

                             )):
        print("Best solution: {}, fitness: {}".format(best, fit))

    def 适应度函数(p):
        p = np.trunc(np.reshape(p, (9, 3)))
        耗材前半部分 = np.array([
                [0, 0],
                [1, 0],
                [2, 0],
                [3, 0],
                [4, 1],
                [5, 1],
                [6, 1],
                [7, 1],
                [8, 1],
        ])
        耗材表 = np.hstack((耗材前半部分, p))
        print(耗材表)
        # 袋装  [0.,         0.78404743, 1.72001252, 4.07501294, 5.         0., 0.92733388]
        # 箱装 [0.78763425, 5.         ,2.61205767 ,5.         ,3.63201236 ,2.6547866, 0.4176828 ]
        # 混装 [0.54901561, 4.80096797, 2.352933,   5.,         0.,         5. , 0.12909913]
        总消耗序列 = []
        总订单序列 = []
        总体积 = 0
        总箱子体积 = 0
        总箱子个数 = 0
        总袋子个数 = 0
        总袋子体积 = 0
        箱_最大个数 = 12678
        袋_最大个数 = 22498
        混_最大个数 = 14837
        箱_最大体积 = 70956
        袋_最大体积 = 46457
        混_最大体积 = 81824
        for 物品序列 in 订单字典.values():
            结果 = 装载函数(物品序列, 耗材表, 权重([0.54901561, 4.80096797, 2.352933, 5., 0., 5., 0.12909913]))
            总消耗序列.append(len(结果))
            总订单序列.append(结果)
            总体积 += sum([容器[3] / 1000000 for 容器 in 结果])
            总箱子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 1])
            总袋子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 0])
            总箱子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 1])
            总袋子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 0])

        if 箱_最大个数 < 总箱子个数 or 袋_最大个数 < 总袋子个数 or 混_最大个数 < sum(总消耗序列) or \
                箱_最大体积 < 总箱子体积 or 袋_最大体积 < 总袋子体积 or 混_最大体积 < 总体积:
            return -1
        数量体积比 = sum(总消耗序列) / 总体积

        print("体积数量比=", 数量体积比)
        return 数量体积比
    # print(结果)
    # print(len(结果))
    # 直观装载图像绘制(结果)
def 差分进化3(容器列表=混合装):


    # def f(x):
    #     return sum((x - 0.5) ** 2)


    bounds = [(1,400) for i in range(27)]

    for best, fit in list(de(第二问适应度函数, bounds, its=30,
                             #initpop=np.array([ [0.34185236, 4.52230808, 2.28562625, 5.,         0.72258032, 5.,0.] for i in range(10)])

                             )):
        print("Best solution: {}, fitness: {}".format(best, fit))


    # print(结果)
    # print(len(结果))
    # 直观装载图像绘制(结果)

def 第二问适应度函数(p):
    p = np.trunc(np.reshape(p, (9, 3)))
    耗材前半部分=np.array([
            [0,0],
            [1, 0],
            [2, 0],
            [3, 0],
            [4, 1],
            [5, 1],
            [6, 1],
            [7, 1],
            [8, 1],
    ])
    耗材表 = np.hstack((耗材前半部分,p))
    # 袋装  [0.,         0.78404743, 1.72001252, 4.07501294, 5.         0., 0.92733388]
    # 箱装 [0.78763425, 5.         ,2.61205767 ,5.         ,3.63201236 ,2.6547866, 0.4176828 ]
    # 混装 [0.54901561, 4.80096797, 2.352933,   5.,         0.,         5. , 0.12909913]
    总消耗序列 = []
    总订单序列 = []
    总体积 = 0
    总箱子体积 = 0
    总箱子个数 = 0
    总袋子个数 = 0
    总袋子体积 = 0
    箱_最大个数 = 12678
    袋_最大个数 = 22498
    混_最大个数 = 14837
    箱_最大体积 = 70956
    袋_最大体积 = 46457
    混_最大体积 = 81824
    for 物品序列 in 订单字典.values():
        结果 = 装载函数2(物品序列, 耗材表, 权重([0.54901561, 4.80096797, 2.352933,   5.,         0.,         5. , 0.12909913]))
        总消耗序列.append(len(结果))
        总订单序列.append(结果)
        总体积 += sum([容器[3] / 1000000 for 容器 in 结果])
        总箱子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 1])
        总袋子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 0])
        总箱子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 1])
        总袋子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 0])

    if 箱_最大个数 < 总箱子个数 or 袋_最大个数<总袋子个数 or 混_最大个数<sum(总消耗序列) or \
            箱_最大体积<总箱子体积 or 袋_最大体积<总袋子体积 or 混_最大体积<总体积 :

        return 1000
    数量体积比 = sum(总消耗序列)/总体积

    print("体积数量比=",数量体积比)
    return 数量体积比


def 第二问适应度函数2():
    p = np.trunc(np.reshape([313, 109, 400, 1  , 202,
                            290, 214,  42, 131, 208,
                            391, 349, 149, 400, 156,
                            23 , 36 , 1 ,  1  , 194,
                            1  , 1  , 74, 177 , 34,
                            1 ,  358, ], (9, 3)))
    耗材前半部分=np.array([
            [0,0],
            [1, 0],
            [2, 0],
            [3, 0],
            [4, 1],
            [5, 1],
            [6, 1],
            [7, 1],
            [8, 1],
    ])
    耗材表 = np.hstack((耗材前半部分,p))
    print(耗材表)
    # 袋装  [0.,         0.78404743, 1.72001252, 4.07501294, 5.         0., 0.92733388]
    # 箱装 [0.78763425, 5.         ,2.61205767 ,5.         ,3.63201236 ,2.6547866, 0.4176828 ]
    # 混装 [0.54901561, 4.80096797, 2.352933,   5.,         0.,         5. , 0.12909913]
    总消耗序列 = []
    总订单序列 = []
    总体积 = 0
    总箱子体积 = 0
    总箱子个数 = 0
    总袋子个数 = 0
    总袋子体积 = 0
    箱_最大个数 = 12678
    袋_最大个数 = 22498
    混_最大个数 = 14837
    箱_最大体积 = 70956
    袋_最大体积 = 46457
    混_最大体积 = 81824
    for 物品序列 in 订单字典.values():
        结果 = 装载函数2(物品序列, 耗材表, 权重([0.54901561, 4.80096797, 2.352933,   5.,         0.,         5. , 0.12909913]))
        总消耗序列.append(len(结果))
        总订单序列.append(结果)
        总体积 += sum([容器[3] / 1000000 for 容器 in 结果])
        总箱子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 1])
        总袋子个数 += sum([1 for 容器 in 结果 if 容器[0][1] == 0])
        总箱子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 1])
        总袋子体积 += sum([容器[3] / 1000000 for 容器 in 结果 if 容器[0][1] == 0])

    if 箱_最大个数 < 总箱子个数 or 袋_最大个数<总袋子个数 or 混_最大个数<sum(总消耗序列) or \
            箱_最大体积<总箱子体积 or 袋_最大体积<总袋子体积 or 混_最大体积<总体积 :

        return 1000
    数量体积比 = sum(总消耗序列)/总体积

    print("体积数量比=",数量体积比,"数量=",sum(总消耗序列),"总统计=",总体积)
    return 数量体积比

if __name__ == "__main__":
    差分进化3()
    # 第二问适应度函数2()

    pass